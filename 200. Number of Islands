Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.

An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

 

Example 1:

Input: grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
Output: 1
Example 2:

Input: grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
Output: 3
 
 
 

class Solution14 {
    public int numIslands(char[][] grid) {
		int[][] parents=new int[grid.length][grid[0].length];                               //     m*i+j就行
		for(int i = 0;i<grid.length;i++){
			for(int j=0;j<grid[0].length;j++){
				parents[i][j]=-1;
			}
		}
        for(int i=0;i<grid.length;i++){
            for(int j=0;j<grid[0].length;j++){
                if(parents[i][j]==-1&&grid[i][j]=='1'){    //遍历grid，找相连的1
					parents=union(grid, i, j, parents,i,j);
				}
			}
		}

		int count = 0;
		for(int i=0;i<grid.length;i++){
			for(int j=0;j<grid[0].length;j++){
				if(parents[i][j]==i*(grid[0].length+grid.length)+j)count++;              //如果指向自己就加1.特例0一直是0,count-1
//				if(parents[i][j]==-1)count--;    
			}
		
		}
		return count;
}
	
	
	public int[][] union(char[][] grid,int i,int j,int[][] parents,int p,int q){   //p,q为父节点，使右下方向所有连续1的指向父节点
		if(grid[i][j]=='1'&&parents[i][j]==-1){
			parents[i][j]=p*(grid[0].length+grid.length)+q;
			if(i+1<grid.length)union(grid,i+1,j,parents,p,q);
			if(j+1<grid[0].length)union(grid,i,j+1,parents,p,q);           
		}
		if(parents[i][j]!=-1&&parents[i][j]!=p*(grid[0].length+grid.length)+q){  //如果发现跟其他相连了就改变父节点指向其他节点
			parents[p][q]=parents[i][j];
			parents[p][q]=parents[i][j];
		}

		return parents;
	}
}

